import { uploadService } from '../services/upload.service'

const state = {
    files: [],
    meta: [],
    palm: {
        jobs: [],
    },
}

const getters = {
    notUploadedFiles: state => {
        return state.filter(file => file.status !== 1)
    },
    successFiles: state => {
        return state.filter(file => file.status === 1)
    },
    warningFiles: state => {
        return state.filter(file => file.status === 2)
    },
    errorFiles: state => {
        return state.filter(file => file.status === 3)
    },
    fatalFiles: state => {
        return state.filter(file => file.status === 4)
    },
}

const actions = {
    reset({ commit }) {
        commit('RESET')
    },
    async createPalmjob({ commit, dispatch }, job) {
        try {
            let resp = await uploadService.createPalmjob(job)
            commit('createPalmjob', resp)
        } catch (error) {
            dispatch('alerts/info', { type: 'error', message: error, status: 3 }, { root: true })
        }
    },
    async requestNameCheck({ dispatch }, files) {
        try {
            return await uploadService.requestNameCheck(files)
        } catch (error) {
            dispatch('alerts/info', { type: 'error', message: error, status: 3 }, { root: true })
            return error
        }
    },
    uploadedFiles: state => {
        return state.files.filter(file => file.status === 1)
    },

    addFile({ commit }, { file }) {
        commit('addFile', file)
    },
    removeFile({ commit }, f) {
        commit('removeFile', f)
    },
    /**
     * Action triggering file upload.
     *
     * Fires upload service function and handles logging in store
     *
     * @since 0.1.0
     *
     * @see services/uploadService
     *
     * @param {Object} obj - An object containing all info need for frontend store and to pass on to service/uploadService.
     * Needed info are: i
     *  {Object} file - the file to upload
     *  {Boolean} ignore_errors - Wether or not to ignore errors generated by the backend (not all errors can be ignored)
     *  {Boolean} ignore_warnings - Wether or not to ignore warnings generated by the backend
     */
    async uploadFiles({ dispatch, commit }, obj) {
        commit('uploadRequest', obj)
        try {
            let resp = await uploadService.upload(obj)
            if (!resp.ok && ![400, 406].indexOf(resp.status)) {
                // throw error if response is not ok and not data not acceptable
                return await resp.json()
            }
            resp = await resp.json()
            commit('uploadResult', { obj, resp })
        } catch (error) {
            dispatch('alerts/info', { type: 'error', message: error, status: 3 }, { root: true })
        }
    },
    async metadataList({ dispatch, commit }, obj) {
        commit('uploadMetaRequest', obj)
        try {
            let resp = await uploadService.uploadMetadataList(obj)
            commit('uploadMetaResult', { resp, file: obj.file })
            return resp
        } catch (error) {
            dispatch('alerts/info', { type: 'error', message: error, status: 3 }, { root: true })
            return error
        }
    },
}

const mutations = {
    RESET(state) {
        const newState = []
        Object.keys(newState).forEach(key => {
            state.files[key] = newState[key]
        })
    },
    createPalmjob(state, job) {
        state.palm.jobs.push(job)
    },
    addFile: (state, file) => state.files.push(file),
    removeFile: (state, elm) => {
        let index = state.files.findIndex(state_elm => state_elm.file === elm.file)
        if (index !== -1) {
            state.files.splice(index, 1)
        }
    },
    uploadRequest(state, { file, ignore_errors, ignore_warnings }) {
        const item = state.files.find(obj => obj.file.name === file.name && obj.file.file_type === file.file_type)
        if (item) {
            item.uploading = true
            item.uploaded = false
            item.ignore_warnings = ignore_warnings
            item.ignore_errors = ignore_errors
        } else {
            state.files.push({
                file,
                resp: {},
                uploaded: false,
                uploading: true,
                ignore_errors,
                ignore_warnings,
            })
        }
    },
    uploadResult(state, { obj, resp }) {
        const item = state.files.find(
            entry => entry.file.name === obj.file.name && entry.file.file_type === obj.file_type
        )
        // let filesOfType = filterObject(state, obj.file.file_type)
        // let item = filesOfType.find(x => x.file.name === obj.file.name)
        item.resp = resp
        item.ignore_warnings = obj.ignore_warnings
        item.ignore_errors = obj.ignore_errors
        item.uploaded = resp.status === 1
        if (obj.ignore_warnings) {
            item.uploaded = resp.status <= 2
        }
        if (obj.ignore_errors) {
            item.uploaded = resp.status <= 3
        }
        item.uploading = false
    },
    updateMessage(state, id, message) {
        state.files[id].message = message
    },
    uploadMetaRequest(state, obj) {
        const item = state.meta.find(data => data.file.name === obj.file.name)
        if (item) {
            item.uploading = true
            item.uploaded = false
        } else {
            state.meta.push({
                file: obj.file,
                resp: {},
                // type: obj.type,
                uploaded: false,
                uploading: true,
            })
        }
    },
    uploadMetaResult: (state, payload) => {
        const item = state.meta.find(i => i.file.name === payload.file.name)
        item.uploaded = payload.resp.status === 1
        item.uploading = false
        item.resp = payload.resp
    },
}

export default {
    namespaced: true,
    state,
    getters,
    actions,
    mutations,
}
